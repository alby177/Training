Can anyone help me with CRC_CHECK and CRC_GEN libraries from oscat304.lib.

My project is using a Wago 750-650 RS232 card to communicate with a laptop. The customer has asked me to use crc and i found the oscat library after some seaching. My problem is, i don't know how to use them. All the information i can find is in German. Can anyone provide me with an example codesys project or provide a step by step guide to implement CRC.

Thank You

Dave

Try to google "A painless guide to CRC error detection algorithms"

Good luck!

Thanks for the reply Avgur.

But my problem is that i don't know how to use the CRC_CHECK and CRC_GEN functions from the oscat304.lib

What i need is a guide on how to use the two functions.

My code so far is below.

PROGRAM COMM2
VAR
	COMM2: SERIAL_INTERFACE;
	M_RECVSTR: BOOL;
	pReceiveStr:POINTER TO ARRAY[0..255] OF BYTE;
	I:INT;
	CRC: BOOL;
	Polynom_32: BOOL;
END_VAR


COMM2(	bCOM_PORT_NR 	:= 2,
			utRECEIVE_BUFFER := RECEIVE_BUFFER,
			iBYTES_TO_SEND	:= LEN(SEND_STRING),
			ptSEND_BUFFER		:= ADR(SEND_STRING),
			xINIT					:= INIT,
     			xOPEN_COM_PORT 	:= TRUE,
			xSTART_SEND		:= SEND );

IF pReceiveStr = 0 THEN (* receive buffer with address of receivers initialize string *)
      pReceiveStr := ADR( ReceiveString );
END_IF;
IF  Receive_Buffer.Index>0 THEN (* new data is received *)
         FOR i:=0 TO 255 DO
            pReceiveStr^[i]:=16#00; (* receive buffer delete *)
         END_FOR;
         FOR i:=0 TO Receive_Buffer.Index-1 DO
            pReceiveStr^[i] :=  Receive_Buffer.Data[ i ]; (* ring buffer data in receive buffer to copy *)
         END_FOR;
         M_RECVSTR:=TRUE;
END_IF;

IF CLEAR_BUFFER THEN (* new request will be sent *)
	FOR i:= 0 TO 255 DO
		Receive_Buffer.Data[i] := 0; (* receive buffer delete *)
	END_FOR
Receive_Buffer.Index := 0; (* receive buffer delete *)
END_IF

CRC:= CRC_CHECK(pRECEIVESTR, I, 469, Polynom_32);

Any help would be appreciated.

Dave

oscat304.lib all help about CRC functions in English
CRC_CHECK
Code:FUNCTION CRC_CHECK : BOOLVAR_INPUT   pt : POINTER TO ARRAY[0..32000] OF BYTE;   size : UINT;END_VARVAR_INPUT CONSTANT   Polynom_L : DWORD;   Polynom_32 : BOOL;END_VARVAREND_VAR(*version 1.1   16. mar. 2008programmer    hugotested by      tobiasCRC_CHECK checks a block of data for a crc checksum and returns true is the checksum is 0 and therfore a error free data transmission.the CRC Polynom is specified with the config variable Polynom_L which holds the lowest 32 bits of the polynom and Polynom_33 which holds bit 33 of the Polynom.A Polynom x4 + X + 1 is represented by 10011.The input data is an array of byte of any size, the function is called by CRC_CHECK(ADR(array),SIZEOF(array)).*)CRC_GENCode:FUNCTION CRC_GEN : DWORDVAR_INPUT   pt : POINTER TO ARRAY[0..32000] OF BYTE;   size : UINT;END_VARVAR_INPUT CONSTANT   Polynom_L : DWORD;   Polynom_32 : BOOL;   init: DWORD;   XOR_out : DWORD;   rev_in : BOOL;   rev_out : BOOL;END_VARVAR   polynom : DWORD;   p_length : INT;   BS : BYTE;   data : DWORD;   count : BYTE;   temp : BOOL;   step: INT;   s4: INT;END_VAR(*version 1.4   16. mar. 2008programmer    hugotested by      tobiasCRC_GEN generates a CRC checksum from a block of data and returns  the checksum in a DWORD to be connected to the data for transmission.the CRC Polynom is specified with the config variable Polynom_L which holds the lowest 32 bits of the polynom and Polynom_33 which holds bit 33 of the Polynom.A Polynom x4 + X + 1 is represented by 10011.The input data is an array of byte of any size, the function is called by CRC_GEN(ADR(array),SIZEOF(array)).*)

