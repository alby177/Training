Hi,I am trying to sort some strings in alphabetical order, I can't find string compare functions. If I write my own in ST how do get the characters out of the string? BYTE is a data type which would be the same size as a STRING character, but I don't think I can read the char. In C it would be c = str[x]; but then C also has string compare functions.Any suggestions welcomeDaveW

_________________David Warren
Luscher UK

Look at system libraries. It depends on the currently used target system.There is a library named SysLibStr.lib, in where you will find :SysStrCmpThis function of type DINT compares lexicographically two strings and returns one of the following values:Return value < 0 String1 smaller than String2Return value = 0 String1 = String2Return value > 0 String1 bigger als String2SysStrCmpIThis function of type DINT checks whether two strings are identical and returns one of the following values:Return value < 0 String1 smaller than String2Return value = 0 String1 = String2Return value > 0 String1 bigger than String2Hope this suits you  

Thanks for the information. I just checked and could not find this lib on my system CoDeSys V3.4 SP3 patch 2 controller is from Bivator.However there is the OSCAT basic lib which has a CODE function that gives the byte value of a char in a string so maybe that will be my starting point.

_________________David WarrenLuscher UK

Hi,I realize this is an old post, but I stumbled upon this thread while searching a solution to the same problem.As STRCMP is not included in the standard library, I guess this would still be relevant information for some.Would it not be possible to solve this challenge using pointers, checking one character at the time?Here is an example, called by STRCMP(ADR(string1), ADR(string2));Code:(*** Declaration ***)FUNCTION STRCMP : BOOLVAR_INPUT   ptStr1 : POINTER TO BYTE;   ptStr2 : POINTER TO BYTE;END_VAR(*** Code***)WHILE TRUE DO   IF (ptStr1^ <> ptStr2^) THEN            (* If two characters are unequal, return FALSE *)      STRCMP := FALSE;      RETURN;   ELSIF ((ptStr1^ = 0) AND (ptStr2^ = 0)) THEN   (* If both strings have reached the NULL TERMINATOR at the same place, the strings are identical *)      STRCMP := TRUE;      RETURN;   ELSE                           (* If the two characters were equal, but were not NULL TERMINATORS, increment to check next character *)      ptStr1 := ptStr1 + 1;      ptStr2 := ptStr2 + 1;   END_IF                              (* Make sure the pointer doesn't wander into unknown territory and create problems *)END_WHILEOf course, you should be careful with having a pointer wandering around in your memory in a "WHILE TRUE"-loop, so an improvement could be to limit the loop to the length of the shortest input string.EDIT: After thinking about it; it should technically not be an issue "wandering around" in the memory this way since you are only reading, not writing. It is of course not encouraged nonetheless.  

