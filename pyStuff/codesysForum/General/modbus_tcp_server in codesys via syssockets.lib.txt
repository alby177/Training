I have created a modbus_tcp server demo program via sdyssockets.lib in codesys system. This server support 01，03，05，06，15，16 modbus function codes.VAR_GLOBAL	VIRTUALPOS: LREAL;	TEST_T:INT;	input_byte:ARRAY[1..250] OF BYTE;	input_byte1:ARRAY[1..250] OF BYTE;       mw_area AT %MB1000:ARRAY[1..500] OF BYTE;       mx_area  : ARRAY[1..512] OF BOOL;      output_byte: ARRAY[1..250]OF BYTE;        mw_temp AT%MW1000: ARRAY[1..500] OF INT;	write_len:INT;	send_do: BOOL;       mw_area_use  AT %MW2000:ARRAY[1..500] OF INT;	ton2: TON;      test_trigger: BOOL;	t1: TON;    receive1_tmp:BYTE;    flag:BOOL;    addressPointer:POINTER TO SOCKADDRESS; address:SOCKADDRESS; ip:STRING:='192.168.39.100'; （*PLC IP ADDRESS*）   receive1:ARRAY[1..300] OF BYTE; port: WORD:=502;   （*MODBUS——TCP port*） objectArray:ARRAY[0..6] OF REAL; tcp_connect_state:BOOL;	tcp_connect_time1:TON;	tcp_connect_time2:TON;	get_last: BOOL;      protocol_id:INT;      device_id:INT;	send1:ARRAY[1..300] OF BYTE;      	tttt AT %MD2000:ARRAY[1..100] OF DINT;END_VARPROGRAM TCP_socket_testVAR	result: BOOL; socketId: DINT; terminate: BOOL;	dwValue: DINT;	bResult: BOOL;	test_state: BOOL;	send: STRING;	error_now: BOOL;	time_trigger: BOOL;	SysSockGetLastError1:SysSockGetLastError;  MasterSocketList:SOCKET_FD_SET;	SlaveSocketList:SOCKET_FD_SET;  SelectTimeOut:SOCKET_TIMEVAL;	TCPindex: INT;	diSize: DINT;	TCPMax: DINT;	tcp_state: INT;	SocketHandle:DINT;	move_ref: INT;END_VARPROGRAM ：TCP_socket_testaddress.sin_addr:=SysSockInetAddr(ip);address.sin_family:=SOCKET_AF_INET;address.sin_port:=SysSockHtons(port);addressPointer:=ADR(address);IF terminate=FALSE THENCASE tcp_state OF0:  socketId := SysSockCreate(SOCKET_AF_INET,SOCKET_STREAM,0); IF socketId <> SOCKET_INVALID THEN  dwValue := 1;  (*Set the option that we can reuse 'old' port addresses *)  SysSockSetOption(socketId, SOCKET_SOL, SOCKET_SO_REUSEADDR, ADR(dwValue), SIZEOF (dwValue)); tcp_state := 10; END_IF10:bResult := SysSockBind(socketId, ADR(address), SIZEOF(address));IF bResult THENtcp_state := 20;END_IF20:bResult := SysSockListen(socketId, 255);IF bResult THENMasterSocketList.fd_count := 1;MasterSocketList.fd_array[0] := socketId;tcp_state := 30;END_IF30:SlaveSocketList:=MasterSocketList;SelectTimeOut.tv_sec := 30;SelectTimeOut.tv_usec := 0;diSize := SysSockSelect(SOCKET_FD_SETSIZE, ADR(SlaveSocketList), 0, 0, ADR(SelectTimeOut));IF diSize > 0 THENtcp_state := 50;TCPindex := 0;END_IF50:SocketHandle := SlaveSocketList.fd_array[TCPindex];IF SocketHandle = socketId THENdiSize := SIZEOF(Address);SocketHandle:=SysSockAccept(socketId, ADR(Address), ADR(address));IF SocketHandle <> SOCKET_INVALID THENTCPMax := SocketHandle;MasterSocketList.fd_array[MasterSocketList.fd_count] := SocketHandle;MasterSocketList.fd_count := MasterSocketList.fd_count + 1;END_IFtcp_state := 100;END_IF100: (* SysSockSend(socketId,ADR(send),SIZEOF(send),1);*)SysSockRecv(SocketHandle,ADR(receive1),SIZEOF(receive1),1);   FOR move_ref:=7 TO receive1[6]+7  DO input_byte1[move_ref-6] :=receive1[move_ref];  END_FOR;  protocol_id:=BYTE_TO_INT(receive1[4]);  device_id:=BYTE_TO_INT(receive1[7]);   IF protocol_id=0 AND  device_id>=0  AND receive1[1]<>0 THEN (*modbus_tcp,protocol_id=0*)    frame_process();   tcp_state := 120;   END_IF;120: IF send_do THENsend1[1]:=receive1[1];send1[2]:=receive1[2];send1[3]:=0;send1[4]:=0;send1[5]:=0;send1[6]:=INT_TO_BYTE(write_len-2); FOR move_ref:=7 TO 7+(write_len-2) DOsend1[move_ref]:=output_byte[move_ref-6];END_FOR;SysSockSend(SocketHandle,ADR(send1),(write_len-1+6),1);receive1[1]:=0;send_do:=FALSE;END_IF;  tcp_state := 100;END_CASE;END_IF;IF terminate = TRUE THEN (* close socket *)  SysSockClose(socketId);  socketId := 0;   tcp_state:=0;  result := FALSE; END_IFPROGRAM frame_processVAR	length_check:INT;       crc_out:WORD;        crc_temp:WORD;        address_temp:INT;        move_to_send:INT;       byte_len:INT;      mod_state:INT;	length_temp: INT;	length_check1: INT;	crc_out1: WORD;      write_area:ARRAY[1..250] OF BYTE;        x:INT;		control_temp: WORD;              offset_temp:INT;END_VARFrame_process IF (( input_byte1[1]<16#FF) AND( input_byte1[1]>=0)) AND( (input_byte1[2]=01) OR (input_byte1[2]=05) OR( input_byte1[2]=03 ) OR( input_byte1[2]=6 )OR(input_byte1[2]=16)OR(input_byte1[2]=15)) THEN   (*CRC16 check action   *)    IF input_byte1[2]=03  OR  input_byte1[2]=06   OR input_byte1[2]=01 OR  input_byte1[2]=05 THEN     length_check:=6;   END_IF;     IF input_byte1[2]=16  OR  input_byte1[2]=15 THEN    length_check:=7+input_byte1[7];    END_IF;   (* crc_check( lengthcrc:= length_check,                          inbyte:=input_byte1,                          CRC16CVT=>crc_out  );    crc_temp:=SHL(BYTE_TO_WORD(input_byte1[length_check+1] ),8) OR  BYTE_TO_WORD(input_byte1[length_check+2] );*)  (* CRC16 check OK then the process is going on ,judge the function code to response *)   IF (*  ( crc_out = crc_temp<>0) AND*) (send_do =FALSE )THEN   CASE input_byte1[2] OF   01:(*read the coils*)        output_byte[1]:=17; output_byte[2]:=01;           address_temp:=SHL(BYTE_TO_INT(input_byte1[3]),8) + ( BYTE_TO_INT(input_byte1[4]));            length_temp:=SHL(BYTE_TO_INT(input_byte1[5]),8) +(BYTE_TO_INT(input_byte1[6]));            mod_state:=length_temp MOD 8;              IF mod_state<>0 THEN                 byte_len:=1+length_temp/8;              ELSE                  byte_len:=length_temp/8;              END_IF;            output_byte[3]:=INT_TO_BYTE(byte_len);             FOR move_to_send:=4 TO byte_len+3 DO             IF mod_state=0 THEN             output_byte[move_to_send].0:=mx_area[address_temp+1+(move_to_send-4)*8]; output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];             output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send].3:=mx_area[address_temp+(move_to_send-4)*8+4];             output_byte[move_to_send].4:=mx_area[address_temp+(move_to_send-4)*8+5]; output_byte[move_to_send].5:=mx_area[address_temp+(move_to_send-4)*8+6];             output_byte[move_to_send].6:=mx_area[address_temp+(move_to_send-4)*8+7]; output_byte[move_to_send].7:=mx_area[address_temp+(move_to_send-4)*8+8];             ELSE               IF move_to_send=byte_len+3 THEN               CASE mod_state OF                1:   output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send]:=output_byte[move_to_send] AND 16#0001;                2:   output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];                       output_byte[move_to_send]:=output_byte[move_to_send] AND 16#0003;                 3:   output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];                       output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send]:=output_byte[move_to_send] AND 16#0007;                 4:   output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];                       output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send].3:=mx_area[address_temp+(move_to_send-4)*8+4];                        output_byte[move_to_send]:=output_byte[move_to_send] AND 16#000F;                  5: output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];                       output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send].3:=mx_area[address_temp+(move_to_send-4)*8+4];                       output_byte[move_to_send].4:=mx_area[address_temp+(move_to_send-4)*8+5];    output_byte[move_to_send]:=output_byte[move_to_send] AND 16#001F;                   6:output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];                       output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send].3:=mx_area[address_temp+(move_to_send-4)*8+4];                       output_byte[move_to_send].4:=mx_area[address_temp+(move_to_send-4)*8+5];    output_byte[move_to_send].5:=mx_area[address_temp+(move_to_send-4)*8+6];                       output_byte[move_to_send]:=output_byte[move_to_send] AND 16#003F;                    7:output_byte[move_to_send].0:=mx_area[address_temp+(move_to_send-4)*8+1];output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];                       output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send].3:=mx_area[address_temp+(move_to_send-4)*8+4];                       output_byte[move_to_send].4:=mx_area[address_temp+(move_to_send-4)*8+5];    output_byte[move_to_send].5:=mx_area[address_temp+(move_to_send-4)*8+6];                         output_byte[move_to_send].6:=mx_area[address_temp+(move_to_send-4)*8+7];     output_byte[move_to_send]:=output_byte[move_to_send] AND 16#007F;                END_CASE;                 ELSE              output_byte[move_to_send].0:=mx_area[address_temp+1+(move_to_send-4)*8]; output_byte[move_to_send].1:=mx_area[address_temp+(move_to_send-4)*8+2];             output_byte[move_to_send].2:=mx_area[address_temp+(move_to_send-4)*8+3]; output_byte[move_to_send].3:=mx_area[address_temp+(move_to_send-4)*8+4];             output_byte[move_to_send].4:=mx_area[address_temp+(move_to_send-4)*8+5]; output_byte[move_to_send].5:=mx_area[address_temp+(move_to_send-4)*8+6];             output_byte[move_to_send].6:=mx_area[address_temp+(move_to_send-4)*8+7]; output_byte[move_to_send].7:=mx_area[address_temp+(move_to_send-4)*8+8];               END_IF;             END_IF;              END_FOR;          length_check1:=3+byte_len;        (*  crc_check( lengthcrc:= length_check1,                          inbyte:=output_byte,                          CRC16CVT=>crc_out1 );          output_byte[4+byte_len]:= WORD_TO_BYTE(SHR((crc_out1 AND 16#FF00 ),8));          output_byte[5+byte_len]:= WORD_TO_BYTE(crc_out1 AND 16#FF );*)           write_len:= 5+byte_len;send_do:=TRUE;  15:(*force multi coils*)             address_temp:=SHL(BYTE_TO_INT(input_byte1[3]),8) + ( BYTE_TO_INT(input_byte1[4]));            length_temp:=SHL(BYTE_TO_INT(input_byte1[5]),8) +(BYTE_TO_INT(input_byte1[6]));             mod_state:=length_temp MOD 8;            FOR move_to_send:=address_temp TO address_temp+length_temp-1  BY 8 DO                 offset_temp:=move_to_send-address_temp;                 IF mod_state=0 THEN                mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;mx_area[move_to_send+4]:=input_byte[offset_temp/8+8].3;                mx_area[move_to_send+5]:=input_byte[offset_temp/8+8].4;mx_area[move_to_send+6]:=input_byte[offset_temp/8+8].5;                mx_area[move_to_send+7]:=input_byte[offset_temp/8+8].6;mx_area[move_to_send+8]:=input_byte[offset_temp/8+8].7;                ELSE                  IF move_to_send-address_temp-length_temp+1<=8 THEN                   CASE mod_state OF                  1:  mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;                  2:  mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                  3:  mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;                  4: mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;mx_area[move_to_send+4]:=input_byte[offset_temp/8+8].3;                  5:  mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;mx_area[move_to_send+4]:=input_byte[offset_temp/8+8].3;                mx_area[move_to_send+5]:=input_byte[offset_temp/8+8].4;                  6:mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;mx_area[move_to_send+4]:=input_byte[offset_temp/8+8].3;                mx_area[move_to_send+5]:=input_byte[offset_temp/8+8].4;mx_area[move_to_send+6]:=input_byte[offset_temp/8+8].5;                 7:  mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;mx_area[move_to_send+4]:=input_byte[offset_temp/8+8].3;                mx_area[move_to_send+5]:=input_byte[offset_temp/8+8].4;mx_area[move_to_send+6]:=input_byte[offset_temp/8+8].5;                mx_area[move_to_send+7]:=input_byte[offset_temp/8+8].6;                    END_CASE;                   ELSE                mx_area[move_to_send+1]:=input_byte[offset_temp/8+8].0;mx_area[move_to_send+2]:=input_byte[offset_temp/8+8].1;                mx_area[move_to_send+3]:=input_byte[offset_temp/8+8].2;mx_area[move_to_send+4]:=input_byte[offset_temp/8+8].3;                mx_area[move_to_send+5]:=input_byte[offset_temp/8+8].4;mx_area[move_to_send+6]:=input_byte[offset_temp/8+8].5;                mx_area[move_to_send+7]:=input_byte[offset_temp/8+8].6;mx_area[move_to_send+8]:=input_byte[offset_temp/8+8].7;                   END_IF;               END_IF;             END_FOR;          FOR move_to_send:=2 TO 6 DO          output_byte[move_to_send]:=input_byte1[move_to_send];          END_FOR;   output_byte[1]:=17;           length_check1:=6;         (* crc_check( lengthcrc:= length_check1,                          inbyte:=output_byte,                          CRC16CVT=>crc_out1 );          output_byte[7]:= WORD_TO_BYTE(SHR((crc_out1 AND 16#FF00 ),8));          output_byte[8]:= WORD_TO_BYTE(crc_out1 AND 16#FF );*)           write_len:= 8;send_do:=TRUE;  05: (*force the coil*)          FOR move_to_send:=2 TO 8 DO          output_byte[move_to_send]:=input_byte1[move_to_send];          END_FOR;           output_byte[1]:=17;         address_temp:=SHL(BYTE_TO_INT(input_byte1[3]),8)+ BYTE_TO_INT(input_byte1[4]);         control_temp:=INT_TO_WORD(SHL(BYTE_TO_INT(input_byte1[5]),8) +(BYTE_TO_INT(input_byte1[6])));         IF control_temp=16#FF00 THEN          mx_area[address_temp+1]:=TRUE;         END_IF;         IF control_temp=16#0000 THEN          mx_area[address_temp+1]:=FALSE;         END_IF;          write_len:= 8;send_do:=TRUE;   03:(*read the registers*)        output_byte[1]:= 17; output_byte[2]:=03;         address_temp:=SHL(BYTE_TO_INT(input_byte1[3]),8) + ( BYTE_TO_INT(input_byte1[4]));         length_temp:=SHL(BYTE_TO_INT(input_byte1[5]),8) +(BYTE_TO_INT(input_byte1[6]));         output_byte[3]:=INT_TO_BYTE((length_temp)*2);         FOR move_to_send:=address_temp TO  address_temp+(length_temp)*2  DO           output_byte[4+move_to_send-address_temp]:=mw_area[move_to_send+address_temp+1];         END_FOR;          length_check1:=3+(length_temp)*2;         (* crc_check( lengthcrc:= length_check1,                          inbyte:=output_byte,                          CRC16CVT=>crc_out1 );          output_byte[4+(length_temp)*2]:= WORD_TO_BYTE(SHR((crc_out1 AND 16#FF00 ),8));          output_byte[5+(length_temp)*2]:= WORD_TO_BYTE(crc_out1 AND 16#FF );*)           write_len:= 5+(length_temp)*2;send_do:=TRUE;   16:(* write the registers*)          FOR move_to_send:=2 TO 6 DO          output_byte[move_to_send]:=input_byte1[move_to_send];          END_FOR;   output_byte[1]:=17;         address_temp:=SHL(BYTE_TO_INT(input_byte1[3]),8)+ BYTE_TO_INT(input_byte1[4]);         length_temp:=SHL(BYTE_TO_INT(input_byte1[5]),8)+ BYTE_TO_INT(input_byte1[6]);          FOR move_to_send:=address_temp TO  address_temp+(length_temp)*2-1  DO           mw_area[move_to_send+address_temp+1]:=input_byte1[8+move_to_send-address_temp];         END_FOR;          length_check1:=6;       (*  crc_check( lengthcrc:= length_check1,                          inbyte:=output_byte,                          CRC16CVT=>crc_out1 );          output_byte[7]:= WORD_TO_BYTE(SHR((crc_out1 AND 16#FF00 ),8));          output_byte[8]:= WORD_TO_BYTE(crc_out1 AND 16#FF );*)           write_len:= 8;send_do:=TRUE;  06:(*force the single register*)          FOR move_to_send:=2 TO 8 DO          output_byte[move_to_send]:=input_byte1[move_to_send];          END_FOR;            output_byte[1]:=17;           address_temp:=SHL(BYTE_TO_INT(input_byte1[3]),8)+ BYTE_TO_INT(input_byte1[4]);           mw_area[address_temp*2+1]:=input_byte1[5];mw_area[address_temp*2+2]:=input_byte1[6];           write_len:= 8;send_do:=TRUE;   END_CASE;   END_IF;END_IF;

