Hi, and merry Christmas to all !I had a strange issue for which I can't find any explanation. The ST program below is called cyclically from a freewheeling task with prio=5. The project has only one more task, a cyclic one with same prio=5 and interval 20ms.The program code executes whenever a rising edge of a BOOL var appears. The first thing it does is setting the var busy to TRUE, and the last thing it does is resetting busy to FALSE.busy var is not modified anywhere else. What happened was - busy var had a value of TRUE. This may only happen if the program is in a process of execution - but it was not. The trigger for code execution (go var) was FALSE. The program doesn't contain any code that may block, and the run counter of the task was incrementing normally.Another possible explanation might be the program execution was somehow interrupt, but I can't imagine how this may happen. Another explanation might be a memory mess, but a project check shows no overlapping memory areas. And I didn't set the var manually.So how is it possible ? Can online change cause this ? Anything else ?Thanks for any suggestions.Code:PROGRAM btnPRESSEDVAREND_VARVAR_INPUT   go: BOOL;      (*button RE*)   button: BYTE;    (* 1=START 2=STOP 3=NXT / STEP *)END_VARVAR_OUTPUT   busy: BOOL;      (*program active*)END_VAR---------------------------------------IF go THEN   busy := 1;   go := 0;   (*some code here   busy var not used*)   go := 0;   busy := 0;END_IF;

same prio is bad idea.as below programming is freewheeling it will be interrupted by other tasks, all spare time is done in this freewheeling task.better is to use the rising edge function in util.libso it could easy happen that busy is high although go is lowand even that busy is low and go is high.and the routine is done. do not reset go here but just look if there is a rising edge.

_________________shooter@home.nlcomputer shooterpaul deelenjacob van wassenaerstraat 29NL 5224 GG 's-Hertogenboschskype shooter paul.deelenphone +31736139136

