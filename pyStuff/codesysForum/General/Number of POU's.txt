I am slightly confused on what objects adds to the total number of POU's?

The maximum number of POU's = 512.

Does it include any function block and function in the project as well as the library? Does each instance of a function block count as 1 POU?

Do data types add to the amount of POU's? Do each instance of a data type count as 1 POU?

In version 2.3 are unsed or unreferenced POU's in a library counted in the total? What about version 2.1?

There is a /debug operator you can use in version 2.1 when you start CoDeSys. How can I accurately count the number of POU's that CoDeSys thinks I am using?

What do the values in debug mode next to the function block mean? example (208/-1/158). Why does it turn red?

maximum number of POU's = Each POU + Instance of each POU + Each data type + Instance of each data type + each function?


I have attached the output from a LST file and I was wondering why there are gaps in the number of POU's?

Thanks

I appoligize this was my post yet I must have made it under a guest account. I also noticed the file was not posted since I did not check the file extensions first. So I am resubmitting the file.

Thanks

_________________Thanks,
Steve Pfeifenroth

Hello,
embedded devices have a fix memory area for code and data of the application. Part of the data area is a table containing all adresses of POUs used in the application. 

There is a number of internal POUs consuming table entries (depending on the target 3 to 10). Each POU and each library consumes an entry.
Specialty: For data types and for functionblocks we generate initialisation POUs. Therefore, a data type declaration consumeas a tabel antry, a function block (not the instance!) consumes 2 entries.

I hope, this information is of some help.

Best regards,

Manfred Werner

Hello Manfred,

I am having this problem again when I ported my V2.1 code over to V2.3. It states I have more than 512 POU's!. What I am still not clear on based on your last post, are all the POU's counted in the libraries even if not used or referenced? The error code from CoDeSys is 3612. I will try to strip unused FB from the libraries and see if that helps.

_________________Thanks,Steve Pfeifenroth

Yes it appears the compiler when first building all interfaces for FB encounters more than 512 POU's then it stops compiling and raises an error even if in my code I don't reference 512 POU's. So I could not compile my code or check for errors until I had less than 512 POU's in my code and libraries. I had to remove unused FB from my PLC manufacturers library in order for my project to compile. Seems to me that the error should only be generated if I reference or use more than 512 POU's rather than if I have more in libraries that are unused.

_________________Thanks,Steve Pfeifenroth

Oh, how nice._______________Webmasters, click here for more traffic!

While digging around   I stumbled upon in the build options (Project-Options-Build-Exclude Objects) a button that you can select POU's and exclude them from the build process. After selcting the POU's for exclusion the POU's now show up in the library manager as green in color like they have been commented out. After trying this with my manufacturers complete library I was able to compile. So 3S has already made the exclusion of POU's during building an option and it appears to work. So thank you 3S  

_________________Thanks,Steve Pfeifenroth

Back to the subject of the number of POU's. There seems to be an issue with the calculation of the number of POU's and using the Project-Options-Build-Exclude Objects-Exclude Unused. It's the chicken before the egg syndrome. CoDeSys seems to calculate the number of POU's before the build of the project (completed successfully), But CoDeSys can't use the Exclude Unused until the project has compiled and the list of used POU's is known. So if you ever add too many POU you will get an error that the maximum number of POU's has been exceeded but doesn't compile your application. So you can't use the automated  Exclude Unused to remove the known Unused POU's because the project will not compile. You will have to start by manually excluding POU's until you get below the 512 limit then after a compile you can go back and use the automated Exclude Unused. It seems it would be nice for the compiler to compile or at least determine first the number and type of POU's first before issuing the warning to allow you to use the automated Exclude Unused. Just a thought.

_________________Thanks,Steve Pfeifenroth

