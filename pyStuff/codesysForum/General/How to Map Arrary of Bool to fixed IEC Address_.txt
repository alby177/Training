Is there a way to map an array of BOOL to a fixed IEC ADDRESS? The following does not workmyBoolArary AT %MX0.0 : ARRAY[0..15] OF BOOL; So Far these are the only combination that I have found to work for fixed memory addressing.  myBool  AT %MX0.0 : BOOL; //Boolean TypemyInput AT %IX0.0 : BOOL;myOut   AT %QX0.0 : BOOL;myByte  AT %MB0   : BYTE; //Byte TypemySINT  AT %MB0   : SINT;myUSINT AT %MB0   : USINT;myByteArary AT %MB0 : ARRAY[0..10] OF BYTE; myWORD  AT %MW0   : WORD; //16 bit typesmyINT   AT %MW0   : INT;myUINT  AT %MW0   : UINT;myWordArary AT %MW0 : ARRAY[0..10] OF WORD; myDWORD AT %MD0   : DWORD; //32bit TypesmyDINT  AT %MD0   : DINT;myUDINT AT %MD0   : UDINT;myReal  AT %MD0   : REAL;myDwordArray AT %MD0 : ARRAY[0..10] OF DWORD;mySTRING AT %MB0 : STRING;  //STRING

_________________The Original SoMachine Ninja

Keep in mind that a variable of type BOOL uses 8 bits of memory space.But to answer your question. You can declare the variable asmyBoolArary AT %MB0 : ARRAY[0..15] OF BOOL;But then you have an array that takes up 16 bytes (16*8 bits) of memory.

When trying to use it with my PLC Controller I get:  Bad declaration, use '%MX' for 'BOOL' variableWith CoDeSys_SP_Win PLC it works correctly.  Is there a way to bit align the array. MeaningmyWORD  AT %MW0   : WORD;myBoolArray AT %MB0 : ARRAY[0..15] OF BOOL;myBoolArray[0]   would equal myWord.0 would equal %MX0.0myBoolArray[1]   would equal myWord.1 would equal %MX0.1myBoolArray[2]   would equal myWord.3 would equal %MX0.2myBoolArray[3]   would equal myWord.4 would equal %MX0.3myBoolArray[4]   would equal myWord.5 would equal %MX0.4myBoolArray[5]   would equal myWord.6 would equal %MX0.5myBoolArray[6]   would equal myWord.7 would equal %MX0.6myBoolArray[7]   would equal myWord.8 would equal %MX0.7myBoolArray[8]   would equal myWord.9 would equal %MX1.0etc

_________________The Original SoMachine Ninja

Check the PACK and UNPACK functions in the UTIL library.

PACK/UNPACK will not work for what I am trying to accomplish.  I use a HMI that uses the symbol configuration.  This allows the HMI  to use variable names instead of fixed addressing.  The problem comes when you have to address a single bit inside the HMI.  It can not directly address the bit directly in the variable name.  This is why a Boolean array works great.  The other reason is the following Example below.For Example if you can bit align the bool array then you could write the following: myBoolArray AT %MB0 : ARRAY[0..15] OF BOOL;    //If it mapped the array %MX0.0 to %MX1.0myWORD AT %MW0 : WORD;myWord:=0;  //Resets all bits in the ArraymyWord:16#FFFF //Set all bits in the ARRAYmyWord:=myWord AND 16#FF00;  //Mask the lower bytemyWord:=myWord AND 16#00FF;  //Mask the Upper bytemyWord:=myWord XOR 16#FFFF;  //INVERT all bitsI know you can accomplish this by remapping the bits into the Array but that makes the variable work in one direction.    Thus requiring the variables to be (IN or OUT) and not (IN and OUT).

_________________The Original SoMachine Ninja

Not exactly an array but I did find the following how to map a DUT with bitwise alignment.  Unfortunately you have to define a new structure for each instance. TYPE my16bitDUT :STRUCT	BIT00 AT %MX0.0 : BOOL; //Boolean Type	BIT01 AT %MX0.1 : BOOL;	BIT02 AT %MX0.2 : BOOL;	BIT03 AT %MX0.3 : BOOL;	BIT04 AT %MX0.4 : BOOL;	BIT05 AT %MX0.5 : BOOL;	BIT06 AT %MX0.6 : BOOL;	BIT07 AT %MX0.7 : BOOL;	BIT08 AT %MX1.0 : BOOL; 	BIT09 AT %MX1.1 : BOOL;	BIT10 AT %MX1.2 : BOOL;	BIT11 AT %MX1.3 : BOOL;	BIT12 AT %MX1.4 : BOOL;	BIT13 AT %MX1.5 : BOOL;	BIT14 AT %MX1.6 : BOOL;	BIT15 AT %MX1.7 : BOOL;END_STRUCTEND_TYPEmy16bit:  my16bitDUT ;myWORD  AT %MW0   : WORD; //16 bit typesNOW the following worksmyWord:=0; //Resets all bits in the ArraymyWord:16#FFFF //Set all bits in the ARRAYmyWord:=myWord AND 16#FF00; //Mask the lower bytemyWord:=myWord AND 16#00FF; //Mask the Upper bytemyWord:=myWord XOR 16#FFFF; //INVERT all bits

_________________The Original SoMachine Ninja

Hi all,Well I've also tried something like that:TYPE t16bitDUT:STRUCT BIT00 : BOOL; //Boolean Type BIT01 : BOOL; //Boolean Type BIT02 : BOOL; //Boolean Type BIT03 : BOOL; //Boolean Type BIT04 : BOOL; //Boolean Type BIT05 : BOOL; //Boolean Type BIT06 : BOOL; //Boolean Type BIT07 : BOOL; //Boolean Type BIT08 : BOOL; //Boolean Type BIT09 : BOOL; //Boolean Type BIT0A : BOOL; //Boolean Type BIT0B : BOOL; //Boolean Type BIT0C : BOOL; //Boolean Type BIT0D : BOOL; //Boolean Type BIT0E : BOOL; //Boolean Type BIT0F : BOOL; //Boolean TypeEND_STRUCTEND_TYPEMY16bDUT AT %MW0 : t16bitDUT; But this does also not work..Maybe it works as:UNION bits: t16bitDUT; all  AT %MW0 : WORD;END_UNIONor maybe as:TYPE u16bitDUTUNION bits: t16bitDUT; all  AT %MW0 : WORD;END_UNIONEND_TYPEMY16bDUT AT %MW0 : u16bitDUT; I'm, not sure..

