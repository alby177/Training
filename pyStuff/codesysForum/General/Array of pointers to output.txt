Hi,I'm fairly new to this and i have been struggeling with something for a few days now.I searched the forum for similar cases, but could not find anything. The closest i found was this thread (viewtopic.php?t=1725). Tried something similar with Pointer to Bool instead of Int, but that didn't workI want to create an array of pointers to my boolean outputs. It shouldnt be so complicated but for some reason i'm not able to get it working.The application is basically a learning program. I want to trigger inputs and save them in the order they are triggered. This should then be mapped to the corresponding outputs.I.e. pseudo code arrayin[1]= input1 at%ix0.0, arrayin[2] = input2 at%ix0.1That is then mapped to output arrayout[1] = output1 at%qx0.0 arrayout[2] = output2 at%qx0.1Very simple and straight forward in my head.However, every way i have tested it it either becomes a programming error (cannot convert pointer to bool sort of) or that the pointer "doesnt work". Tested creating a standard array of bool and added output1 and output2 to it, when i then try to activate one of them (just arrayout[1]:=TRUE;) it gives the True value to arrayout[1] but not the adress for output1. Thats why i thought i must need an array of pointers (which point to my outputs/inputs).I hope atleast someone understands what i mean..Thanks in advance, br Chris

why use pointers?just say output0:= outputarray[0];output1:=outputarray[1];etc.pointers can be used but make the program only possible on one type of controller.in the GLOBAL VAR list just say output0 at %QX0.0:BOOL;etcyou can also do this in the PLC config but this is easier. and will print in your program.

_________________shooter@home.nlcomputer shooterpaul deelenjacob van wassenaerstraat 29NL 5224 GG 's-Hertogenboschskype shooter paul.deelenphone +31736139136

Hi,Sorry for my late reply.The reason i started thinking of using pointers was that i could not get my program to work as i wanted.However, when i tested what you wrote  output0:= outputarray[0];output1:=outputarray[1];tested byoutputarray[0]:=1;(gave output0 = true)that worked. but what i wrote originally wasoutputarray[0]:=output0;andoutputarray[0]:=1;(did not give output0 = true)And i could not understand why it didnt work.. To be frank, I still dont understand why the inverted declaration (as in yours') works but not mine.I feel i have missed something basic with this. If you got the time i would be very grateful if you could explain it.Thanks a lot.br

outputarray[0]:=output0;this will write the state of the output in the arrayandoutputarray[0]:=1;this will put a 1 in the array.nowhere you say output0:=  ????

_________________shooter@home.nlcomputer shooterpaul deelenjacob van wassenaerstraat 29NL 5224 GG 's-Hertogenboschskype shooter paul.deelenphone +31736139136

and sorry chris in your first post the sequence was wrong ( i did not see this as it was all in one line.

_________________shooter@home.nlcomputer shooterpaul deelenjacob van wassenaerstraat 29NL 5224 GG 's-Hertogenboschskype shooter paul.deelenphone +31736139136

Hi************outputarray[0]:=output0;this will write the state of the output in the arrayandoutputarray[0]:=1;this will put a 1 in the array.nowhere you say output0:= ????*****************=> outputarray[0] = 1 (array memory of position 0 = 1)Ah ok. So with the inverse;output0:=outputarray[0];andoutputarray[0]:=1;=> output0 (@qx0.0) = 1 (true/high)And here write the  state of the array to the output..is connecting the array with the adress of the output0. That was what i was after, connecting the output adress to the array. I thought it would work either way.This atleast solved that problem and i think i understand the difference how Codesys handles local-/temporary memory and in/output adresses. I just need to keep track of how i want it to function.Thanks again, br

a direct connect with an array is impossible, you can NOT makeVARarrayoutput[0] at QX0.0 :BOOL;etcEND_VARbut you can write a complete word from array to the outputsVARmaxarrays is ie 5arrayout [maxarrays] array of word;arrayoutput [maxarrays,16] of BOOL;output0 AT QW0:WORD;output1 ATQW1:WORD;etcEND_VARin program you makea loop withfor B = 1 to maxarraysarrayout[B]:=0; // empty the counterfor A = 0 to 16arrayout[B]:= arrayout[B]+ (arrayoutput[B,A]*EXPT(2,A))  // if output in array is TRUE (1) then add 2 power A// next Anext Bnow they are in wordsthenoutput0 := arrayout[0];etcthis is all straight forward without any pointers, so very flexible and can be used on any type of PLC.in util.lib there isEXTRACT(in,n) The n-th bit of DWORD in is returned in BOOl PACK Up to 8 bits are packed into a byte PUTBIT A bit of a DWORD is set to a certain value UNPACK A Byte is returned as single bits for the rest of this have a look at www.oscat.de (also english version available.get the lib, the pdf and the txt version.

_________________shooter@home.nlcomputer shooterpaul deelenjacob van wassenaerstraat 29NL 5224 GG 's-Hertogenboschskype shooter paul.deelenphone +31736139136

