What is 3s stance on casting?I have come across the following issue but have seen this before with other calculations.Code:(* lopass filter *)q_lOutput :DINT;i_sInput :INT;i_sFilter :INT;q_lOutput := q_lOutput + SHR(((INT_TO_DINT(i_sInput) - q_lOutput ) * i_sFilter), 10);I had this in a fb and it was called with filter = 1024 and input = 0. A fb on line 1 calculated the q_lOutput  correctly = 0 the fb on line 2 calculated some overflow value. This was tested on a C167 infineon target not in simulation mode. I then cast the filter by using INT_TO_DINT and it appeared to take care of the issue. Does 3s have any standards or best practices on when and when not to cast?

_________________Thanks,
Steve Pfeifenroth

your filter is only a INT and not double so calcs will be wrong.

_________________shooter@home.nlcomputer shooterpaul deelenjacob van wassenaerstraat 29NL 5224 GG 's-Hertogenboschskype shooter paul.deelenphone +31736139136

Yes you are correct, but my concern is sometimes it works and sometimes it doesn't especially for the same filter number calling two instances of the FB. One will be correct and the other is not. So how can the compiler get it correct once and not be consistently wrong? Not being wrong 100% of the time scares me. It makes debugging difficult. Also if you ran this in simulation mode on your PC you will get the correct value 100% of the time.

_________________Thanks,Steve Pfeifenroth

