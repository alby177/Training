I am using a Modicon M251 PLC and my customer has requested that we store a number of (real) values in the PLC at a rate of 4Hz and retain the historic data for 3 days. Ideally this would be in a circular buffer where new data overwrites the oldest data but other options may be acceptable. The customer would like to be able to download the data from the PLC to a laptop as and when they like.Has anyone done anything similar to this or are there any function blocks available to implement this?ThanksTony

It looks like your customer wants 1 million samples, which would be 4 MB (4 BYTES per REAL) - or even worse, if readable numbers are required, then you are looking at maybe 6 CHARS per sample on average for 7 MB (6 chars + comma).You maybe have two options:Create a pseudo ring buffer - easy one requires 2x array size.  I can attach sample code, but I think this is not realistic for the hardware..Break up the data to hours and save the files.  Then at least you could just write to flash for an hour and close the file.  Then compile the hour files every midnight to a big daily file your customer could read out.  Keep the last xx days of files.Others?

_________________Scott CunninghamKEB America, Inc.www.kebblog.comwww.kebamerica.com

Hey, thanks for the reply and suggestions. Were you thinking of holding the data for the last hour in an array rather than writing each value to file every 0.25 second? Would it be more efficient to do this?As an option 3 (and shoot me down if its madness) I thought of creating a large fixed size file big enough to store a million records times the size of a record (which would need to be fixed). I could then implement a pseudo ring buffer using the SysLibFile functions (e.g. SysFileSetPos) to index into the file. While not without its own complications, this method would eliminate the need to paste files together.I would appreciate you views on this.Thanks again for your reply  

I have solved this before by opening a sequential file for writing, and then writing each piece of data every quarter of a second. After an hour, I close the file and open a new file and start the process again.   With a flash drive, this is very low headroom and hardware usage.  The code for this is simpler than first storing into RAM and then dumping to a file. The only drawback is if there is a power loss, that our data is gone and lost because the file is corrupted. It is a basic solution for small hardware. Keep in mind, saving the data into RAM and then dumping also results in data loss on power cycle. In either case, for my project it was not critical to maintain the last hour of data. If your platform supports random access files, and you can set up a large file and randomly access points, then I would say your third option could be better, assuming the file is usable after power loss.

_________________Scott CunninghamKEB America, Inc.www.kebblog.comwww.kebamerica.com

Thanks Scott.You have raised an important point! If I implemented it the way that you suggested, in the event of a power failure, the most you would loose is 1 hours worth of data (probably the most important hour but hey!). If I used a random access file then potentially the whole file could get screwed up and 3 days worth has gone down the pan.Something to think about!Thanks for your input, it is really appreciated.Tony  

Hi,There is a standard feature DataLogging.The ability to store data in the Log files on 65,536 records for 255 characters in a line.Writing to Flash memory controller (128 MB) or on an SD card.Recording can be made with much greater frequency than 4 Hz .....Attachment:SoMachine - Data Logging Functions DataLogging Library Guide.zip

