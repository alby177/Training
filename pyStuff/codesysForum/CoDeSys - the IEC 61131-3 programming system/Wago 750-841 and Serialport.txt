Hi,I have an application were need to read a 6 byte telegram on my serialport twice per second (ASCII value from a weightcell).I'm having troubble getting the wago app.note (serial_interface.lib, sercomm.lib) to work so I figured I could just make the function myself.In the documentation for the serialmodule (750-653) there is a step by step procedure on how to initialize and read data. Have anyone tried to do this without using the libraries? just reading and writing byte for byte following the manual.The default settings in the module looks to be right for the application already so I shouldn't need to change them in my app.The Wago app. note just gives me "sercomm" built warnings and then a "wrong array index" alarm when I try to run it.Any tips would be greatly appriciated.Regards,Havard

Havardf wrote:Hi,Have anyone tried to do this without using the libraries? just reading and writing byte for byte following the manual.I have coded this. It works fine with Wago module 750-650/000-006 (9600/E/8/1). Here is code exampleCode:VAR   TA AT %I*:BOOL;   RR AT %I*:BOOL;   IA AT %I*:BOOL;   IBF AT %I*:BOOL;   IL0 AT %I*:BOOL;   IL1 AT %I*:BOOL;   IL2 AT %I*:BOOL;   IB1 AT %I*:BYTE;   IB2 AT %I*:BYTE;   IB3 AT %I*:BYTE;   TR AT %Q*:BOOL;   RA AT %Q*:BOOL;   IR AT %Q*:BOOL;   OL0 AT %Q*:BOOL;   OL1 AT %Q*:BOOL;   OL2 AT %Q*:BOOL;   QB1 AT %Q*:BYTE;   QB2 AT %Q*:BYTE;   QB3 AT %Q*:BYTE;   step:BYTE:=0;(*program step*)END_VAR   CASE step OF      (*initialization*)      0:         IR:=TRUE; (*set IR*)         (*clear output bytes*)         OL0:=FALSE;         OL1:=FALSE;         OL2:=FALSE;         QB1:=0;         QB2:=0;         QB3:=0;         xInit_Failed:=FALSE;         xRead_Failed:=FALSE;         xWrite_Failed:=FALSE;         step:=1;(*go to step 1*)         RETURN;      (* initialization check*)      1:         IF IA=TRUE THEN            (*initialization done!*)            step:=2;(*go to step 2*)         ELSE            (*initialization failed, exit program*)            xTrans_Request:=FALSE;            xInit_Failed:=TRUE;            step:=0;         END_IF         IR:=FALSE; (*reset IR*)         RETURN;         (*write data*)      2:         set bits OL0-OL2 and bytes QB1-QB3 respectively               (*invert TR*)            TR:=NOT TR;            step:=3; (*go to step 3*)               (*clear receive buffer*)         RETURN;      (*check writing*)      3:         IF TR=TA THEN            step:=4; (*go to step 4*)            read_flag:=FALSE;            (*start timer*)         ELSE            (*writing failed, exit*)            xTrans_Request:=FALSE;            xWrite_Failed:=TRUE;            step:=0;         END_IF         RETURN;      (*read data*)      4:         (*check input buffer overflow*)         IF IBF THEN            xTrans_Request:=FALSE;            xRead_Failed:=TRUE;            step:=0;            RETURN;         END_IF         (*check data for reading*)         IF RR<>RA THEN            (*check bits IL0-IL2 and read data from bytes IB1-IB3*)               RA:=NOT RA;            ELSE            (*check timer*)         END_IF         RETURN;   END_CASEELSE   step:=0;END_IF

Thanks a lot for that example, just the answer I was looking (and hoping) for!Regards,Håvard

