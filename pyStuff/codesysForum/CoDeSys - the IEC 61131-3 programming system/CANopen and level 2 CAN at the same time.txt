In the document "CANopen for 3S Runtime Systems", I read: "Specifically still possible: The application can send and directly receive own CAN messages to/from the bus. (Layer 2)". However, this doesn't work on the device I'm working with. If I read from the bus, the CANopen Master will be stuck in state 3. The device will respond with the correct Device Type, but apparently the CANopen libraries will not "see" that and instead do an SDO abort due to timeout. Is this expected behaviour? Is is possible to read a message from CAN, then un-read it or push it to the CANopen libraries?

You can add a second CAN device, with the same netID as the CAN device which the CANopen master is connected to.Now the CAN and CANopen devices are 'independent' (but on the same bus). Maybe that works?Regards,Edwin.

Edwin wrote:You can add a second CAN device, with the same netID as the CAN device which the CANopen master is connected to.Now the CAN and CANopen devices are 'independent' (but on the same bus). Maybe that works?I don't understand how you mean. The device has 4 CAN interfaces. In the PLC configuration, for each interface, I can select either "CANX" or "Not used". In this case, it's the second interface, so I'm selecting "CAN1". Additionally, I have added two "CAN/CANopen Master" nodes. The first one corresponds to CAN0 and is unused. The second one is for the CAN1 interface. Now, in the application code, I'm reading and writing to the interface with xc_can_write and xc_can_read. This apparently interferes with the CANopen Master. Should I use other functions? I've noticed that in 3S_CanDrv.lib, there are functions Can_Read and Can_Write, but I cannot find any documentation for them. I've also noticed that it has a pCanRxBuffer, but cannot find docs for that one either. In particular, I would need to know the number of CAN frames in pCanRxBuffer.

