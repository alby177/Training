Hello,

I'm working on a project using a Wago 750-842 and I'm having some trouble.
The program has to be the same on many controller but they don't have the same configuration. Some have an analog input other don't. So here come my problem:
I can't use %IX0.0 because if the controller has an analog input the address changes!
For now I'm using a big array like:
Code:inputs[0] := %IX0.0;inputs[1] := %IX0.1;inputs[2] := %IX0.2;inputs[3] := %IX0.3;inputs[4] := %IX0.4;inputs[5] := %IX0.5;inputs[6] := %IX0.6;inputs[7] := %IX0.7;inputs[8] := %IX0.8;inputs[9] := %IX0.9;inputs[10] := %IX0.10;.....and then using an offset to get the good value from the array.Code:myVar := inputs[offset]But it consumes a lot of memory!I don't kown if there is a way to do it better, like :Code:myVar := %IX0.0 + offset ?

Anybody knows if it's possible, or if using an array is the only way...?

Thanks
Raoul

IMHO the simplest way is to configure all I/O variables in PLC configuration and make separate project for each PLCs with different configuration.

If you really need natural dynamic bit addressing for the Input memory then you may use a function. For example:

Code:FUNCTION GetInpBit : BOOLVAR_INPUT   bit_offset: UINT;END_VARVAR   byInpArr AT %IB0: ARRAY[0..100] OF BYTE;     (*byte array in I memory*)END_VARVAR CONSTANT   byBitArr : ARRAY[0..7] OF BYTE := 16#01,16#02,16#04,16#08,16#10,16#20,16#40,16#80;END_VAR(* get the byte AND  select the bit    *)GetInpBit:=BYTE_TO_BOOL(byInpArr[bit_offset/8] AND byBitArr[bit_offset MOD 8]);

Regards 

__________________IP_

It works like a charm !  

Thanks

