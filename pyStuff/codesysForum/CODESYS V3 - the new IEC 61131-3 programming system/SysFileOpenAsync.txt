When I run the following program, I get in ResultAsync the error 2.That means invalid parameter for this operation.What can be the cause of this ?// DECLARATION:PROGRAM TestVARudStateOpen: UDINT := 16#FFFFFFFF;TestFB : SysFileAsyncFB;SFO : tSysFileOpen;TestString: STRING;TestAccessMode: UDINT;Result, ResultAsync, OUT, hJob: UDINT;	END_VAR// IMPLEMENTATION:SFO.szFile := TestString;SFO.am := TestAccessMode;SFO.pResult := ADR(Result);SFO.pulOut := ADR(OUT);hJob := TestFB.SysFileOpenAsync(ADR(SFO), ADR(udStateOpen), ADR(ResultAsync));

Up.The same question. Is there a complete example of using asynchronous (non blocking) read? I need to read input event ('/dev/input/event1').CoDeSys 3.5.10.x.

Worked example.Code:PROGRAM PLC_PRGvar constant   STATE_IDLE:    byte := 0;   STATE_CONFIG:    byte := 1;   STATE_OPEN:    byte := 2;   STATE_FLUSH:    byte := 3;   STATE_READ:    byte := 4;   STATE_READWAIT: byte := 5;   STATE_CATCHEVENT: byte := 6;   STATE_CLOSE:    byte := 7;   STATE_CLOSEWAIT: byte := 8;   end_varvar      ready: bool;      step: byte := 1;      state: udint;   result: RTS_IEC_RESULT;   file : SysFileAsync.SysFileAsyncFB;   jobparams : SysFileAsync.AsyncJob_Param;   taskName : string := 'EventTask';      open : SysFileAsync.tSysFileOpen;   write: SysFileAsync.tSysFileWrite;   read: SysFileAsync.tSysFileRead;   close : SysFileAsync.tSysFileClose;   ulOut : SysFileAsync.RTS_IEC_RESULT;         fileName: string := '/dev/input/event1';   event: array [0 .. 15 ] of byte;   end_varcase step of      STATE_CONFIG:         jobparams.TaskParam.pszTaskname    := adr( taskName );      jobparams.TaskParam.ulTaskPriority    := SysFileAsync.TASK_PRIORITIES.TASKPRIO_IDLE;      jobparams.TaskParam.ulTaskSleepTime := 10;      jobparams.TaskParam.phTaskHandle    := SysFileAsync.RTS_INVALID_HANDLE;      jobparams.TaskParam.ulEndTaskAfterJob := 0;            file.AsyncSetJobParams( SysFileAsync.ASYNCJOB_TASK, 1000000, adr( jobparams ) );            step := STATE_OPEN;         STATE_OPEN:         open.szFile := fileName;      open.am := SysFileAsync.ACCESS_MODE.AM_READ;      open.pulOut := adr( ulOut );            file.SysFileOpenAsync( adr( open ), adr( state ), adr( result ) );      step := STATE_READ;         STATE_READ:         if state = SysFileAsync.ASYNCSTATE_READY or state = SysFileAsync.ASYNCSTATE_ERROR or state = SysFileAsync.ASYNCSTATE_TIMEOUT then                  (* The file is correctly opened *)         read.pbyBuffer := adr( event );         read.ulSize   := sizeof( event );         read.pResult   := adr( result);         read.pulOut    := adr( ulOut );         State := 0;                  file.SysFileReadAsync( adr( read ), adr( state ), adr( result ) );                  step := STATE_READWAIT;      end_if         STATE_READWAIT:            ready := state = SysFileAsync.ASYNCSTATE_READY or state = SysFileAsync.ASYNCSTATE_ERROR or State = SysFileAsync.ASYNCSTATE_TIMEOUT;      step :=   sel( ready, STATE_READWAIT, STATE_CATCHEVENT );      STATE_CATCHEVENT:         step := STATE_READ;         STATE_CLOSE:         close.pulOut := adr(ulOut);      file.SysFileCloseAsync( adr( close ), adr( state ), adr( result ) );            step := STATE_CLOSEWAIT;         STATE_CLOSEWAIT:         ready := state = SysFileAsync.ASYNCSTATE_READY or state = SysFileAsync.ASYNCSTATE_ERROR or State = SysFileAsync.ASYNCSTATE_TIMEOUT;            (* The file is correctly closed *)      step :=   sel( ready, STATE_CLOSEWAIT, STATE_IDLE );               STATE_IDLE:   ;   end_case

