Hello,I am currently working on a TCP/IP implementation in CoDeSys V3, whereas the IEC61131-3 program has to be the server. For whatever reason, it is not possible to receive any data from the point of view of TCP client, even though a working connection could be established. I am using the NetBaseServices.Please refer to the following code:Code:---HEADER---PROGRAM TCP_ClientVAR    bFirst: BOOL := TRUE;   My_Data: ARRAY[0..4] OF BYTE := [0,1,2,3,4];    NBS_IP_Adress : NBS.IP_ADDR;       TCPClient : NBS.TCP_Client;   TCPClient_xDone : BOOL;   TCPClient_xBusy : BOOL;   TCPClient_eError : NBS.ERROR;   TCPClient_xActive : BOOL;   TCPClient_hConn : NBS.CAA.HANDLE;      TCPServer : NBS.TCP_Server;   TCPServer_xDone : BOOL;   TCPServer_xBusy : BOOL;   TCPServer_eError : NBS.ERROR;   TCPServer_xError : BOOL;   TCPServer_hServer : NBS.CAA.HANDLE;      TCPConnection : NBS.TCP_Connection;   TCPConnection_xDone: BOOL;   TCPConnection_eError : NBS.ERROR;   TCPConnection_xActive : BOOL;      TCPWrite : NBS.TCP_Write;   TCPWrite_xDone : BOOL;   TCPWrite_xBusy : BOOL;   TCPWrite_eError : NBS.ERROR;   TCPWrite_xError : BOOL;END_VAR ---PROGRAM---IF bFirst THEN    bFirst := FALSE;      // CoDeSys Automation Alliance (CAA) Interfaces - NetBaseServices (NBS)    NBS_IP_Adress.sAddr := '192.168.178.39';   TCPServer(      xEnable := TRUE,      ipAddr := NBS_IP_Adress,      uiPort := 61002,      xDone => TCPServer_xDone,      xBusy => TCPServer_xBusy,      eError => TCPServer_eError,      xError => TCPServer_xError,   );END_IF My_Data[0] := My_Data[0]+1; My_Data[1] := My_Data[1]+1; My_Data[2] := My_Data[2]+1; My_Data[3] := My_Data[3]+1; My_Data[4] := My_Data[4]+1; TCPConnection(   xEnable := TRUE,   hServer := TCPServer.hServer,   xDone => TCPConnection_xDone,   eError => TCPConnection_eError,   xActive => TCPConnection_xActive      );IF TCPConnection.xDone THEN   TCPWrite(      xExecute := TRUE,      hConnection := TCPConnection.hConnection,      pData := ADR(My_Data),      szSize := SIZEOF(My_Data),      xDone => TCPWrite_xDone,      xBusy => TCPWrite_xBusy,      xError => TCPWrite_xError,      eError => TCPWrite_eError   );   END_IFDo you have an idea what is wrong with my implementation?Thanks in advance for your kind support.Regards,Robert

I'm not 100% sure, but here some things that might help:- Always call the TCPServer FB (not just the first scan) with xEnable TRUE.- Enable the TCPConnection when the TCPServer handle is not invalid or 0.- Execute the TCPWrite FB when the TCPConnection is Active (not when it is done)- An Execute input of the FB is a trigger to start it, therefore the data is only send once in your application. Replace the TRUE for a puls generator or something similar.

Hey TimvH,"Always call the TCPServer FB (not just the first scan) with xEnable TRUE" helped me out! Thank you for your help!

I would recommend using the OsCat Network Library it has been tested and validated.  You can use the IP_CONTROL FB's to implement you own TCP SERVER.You have to be signed in to download.  This has been updated for CoDeSys V3.http://www.oscat.de/community/index.php ... 784.0.html

_________________The Original SoMachine Ninja

Hello Robinston,I tried your code (and I ran TCPServer always, as it was recommended, not only in the first run), but in my TCPWrite FB, I get "Invalid Handle", even if I try the other recommended issues, posted by TimvH.Did you only deleted the IF bfirst THEN-Loop - or did you some other changes in your code until it worked?Thanks in advance for your kind help.Best RegardsRuwen

