I am looking to build a library that is geared toward code reuse, and has a very simple API.  Specifically, some basic data structures with methods using the new OOP capabilities (obviously without dynamic memory capabilities).  I am using CoDeSys v3.4 SP3 Patch 2, and using the standard text language.In C, I would cast an object, variable, etc. to a void pointer and manage the void pointer in the backend of the API.  Then cast the returned pointer back to an object from there.Code:   MyObject o;   DataStruct d;   //Do stuff with o   d.store((void *)o);   //Some time later   o = (MyObject) d.retrieve();In C++ I would just use the template library to do something similarCode:  MyObject o;  DataStruct<MyObject> d;  //Do stuff with o  d.store(o);  //Later  o = d.retrieve(); Java obviously has something similar, but I would probably store an Object, and then make my specific object inherit from the Object class.  Since it is inherited, it can be managed under the parent class.My question is, in CoDeSys, what can I do to accomplish this behavior?  My original thought was to store pointers to bytes, but that unfortunately tries to convert the object to a byte it seems.  I haven't tried it yet, but I thought about trying to do the Java pattern of having an object class and using that data type in the library, and then inheriting from that object to store whatever data I want.Any help or insight would be greatly appreciated.

Hi,in CoDeSys DataStructs don'have methods. You have to use function block with method. I think you are looking for a generic approach. Try to use interfaces for that.Define a interface:Code:INTERFACE IF_GenericInterfaceCreate a function block that implements that interface:Code:FUNCTION_BLOCK FB_ImplementsInterface IMPLEMENTS IF_GenericInterfaceCreate a second function block with the store method. Input parameter is the interface:Quote:METHOD PUBLIC Store : BOOLVAR_INPUT	ifInterface	: IF_GenericInterface;END_VARCreate a second methode retrieve with the return value of the interface:Code:METHOD PUBLIC Retrieve : IF_GenericInterfaceInstead of the two methods, you can also use a property. This hsould be more applicable in your case.Declaration in user code:Quote:VAR	fbImplementsInterface	: FB_ImplementsInterface;	fbStoreAndReceive		: FB_StoreAndReceive;	ifGenericInterface		: IF_GenericInterface;END_VARUsage:Code:// Store instancefbStoreAndReceive.Store(fbImplementsInterface);// Receive instance as interfaceifGenericInterface := fbStoreAndReceive.Retrieve();The usage of interfaces only makes sense if they have additional properties or methods and you have different objects that implement this interface.Hope this is helpful for you  

Thanks for the reply.  Next chance I get, I was going to try out a pattern similar to what you describe.  I'll post back when I give it a shot.Also, the interface would make sense here, as the end user would need the ability to define their own data types/methods/etc, so they could implement the interface with to their own liking.

Hello,Can you give me an example:so how can i declare a pointer to function in my library.and how can i pass a pointer to function to my external library?thank you 

