Hi AllI'm trying to make a logging function and when I call this function I want to connect a structure that holds the data. Within this structure I have 1 keyword of type BYTE. To the function I give a pointer to this struct and the length of this struct. THIS WORKS Within the logging function, for timing reasons, I need to make a buffer that holds e.g. 10 loggings before the data is saved to disk. So I need something that can create:Code: s_arrDestination : ARRAY [0..10] of <UNKNOWN_STRUCTURE>So I started to 'play' with pointers, but my laptop keeps on crashing, so I'm doing something realy wrong. Code until now:Code:   s_nLoggingBufferSize := (TIME_TO_UDINT(i_tmCfgDataWriteRate)                      / TIME_TO_UDINT(i_tmCfgSampleRate)) * i_nDataLength;   // Determine amount of bytes for data buffer 10ms /2ms *2431 Bytes         s_ptDestination := ADR(s_ptDestination);                                 // Get pointer to data buffer   FOR s_nLoggingBufferIndex := 0 TO (s_nLoggingBufferSize - 1) DO         // For internalbuffer[n]       s_ptSource := i_ptData;                                          // Pointer to external structure holding data      FOR s_nLoggingDataIndex :=0 TO (i_nDataLength - 1) DO                  // For all bytes in external structure//         s_ptDestination^ := s_ptSource^;                              // Copy data from external to internal buffer         s_ptDestination := s_ptDestination + (s_nLoggingDataIndex + 1);            // Update data pointer internal buffer         s_ptSource := s_ptSource + (s_nLoggingDataIndex + 1);               // Update data pointer external buffer      END_FOR      s_nLoggingBufferIndex := s_nLoggingBufferIndex + (i_nDataLength - 1);         // internalbuffer[n+1]   END_FORThe line s_ptDestination^ := s_ptSource^ is marked as comment because this causes the laptop crash. So hopefully someone can help me with this issue. RegardsLudoPlease no OSCAT comments, couldn't find anything helpfull on that site until now.

 s_ptDestination := ADR(s_ptDestination);                                 // Get pointer to data bufferThis has no effect...You have to point the pointer to something else before being able to use it.So when you try to dereference the pointer the pointer is still not initialized therefore it fails.s_ptDestination := ADR(s_buffer);  // ADR returns the address of the object (not pointer) you pass as parameter...Hope this helps...

_________________http://www.robotecnik.com - robots, CNC and PLC programming.

SeeSptDestination:=adr(sptdestination).

HelloCan you explain what exactly you want to do? Why do you need an unknown type and then "by convention" say its a byte? Is it really the type which is unknown?This would be a perfect usecase for an interface or a baseclass, you could also extend the type struct and make your "own" structure.So you have an interface like, "LogEntry" or "ILoggingSource" with a method "GetLogMessage". All the FB's and Functions which need to log implement this interface, and this interface would be the item in your list.Here is some "sample" code:Code:s_arrDestination : ARRAY [0..10] of <ILoggingSource>for each loggingItem in s_arrDestination{   File.Write(loggingItem.getLogMessage);}By the way, you use prefixes in your coding, this is called "Hungarian Notation" and it is a terrible style of coding. It makes your code unreadabale. Also, its scientifically proved that hungarian notation causes braindamage or even braindeath.I know even in the PLC Open guidelines they use it, but its still eyecancer. Please avoid it never ever think of doing it again in your future.Linus Torvalds (against Systems Hungarian):Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged—the compiler knows the types anyway and can check those, and it only confuses the programmer.[10]https://en.wikipedia.org/wiki/Hungarian_notation

Quote:By the way, you use prefixes in your coding, this is called "Hungarian Notation" and it is a terrible style of coding. It makes your code unreadabaleAmen!

