Hello everyone,I am trying to understand what are differences between them. Of course, I know the basics. I know you can declare a pointer whitout initialize it, I know you get a reference from a existing variable and so on...But I want to know in the softmotion context. For example, the typical FBs like MC_MOVE use a VAR_IN_OUT to pass the the AXIS variable ( for example, AXIS_REF_VIRTUAL_SM3).If I have my MC_MOVE inside another FB_AXIS, I can pass a pointer to axis through FB_AXIS, dereference it and pass it to the the MC_MOVE fb block.but, why is not possible to use a reference to axis to pass it through FB_axis towards MC_MOVE ?What are the rules when working with softmotion and references ?A VAR_IN_OUT variable is an automatic pointer dereferenced ?Thanks in advance. Bye

A VAR_IN_OUT parameter and a REFERENCE parameter are pretty much the same thing and used in exactly the same way.References are automatically de-referenced pointers.and use exactly the same underlying mechanism as pointers.  The difference is in the language semantics.

There are more differences than just language semantics!A VAR_IN_OUT is passed by reference and also is REQUIRED when you call the POU - you get a compile error if you don’t include it.  This is a good way to force a user to not forget to pass an important variable or a variable that changes value (like soft motion axis data!).  It can also be a real nuisance to include in every call if it is only a setup parameter.  Also note that a VAR_IN_OUT tells the user the variable can be changed by either outside or inside the POU (in and out).A REFERENCE TO is also passed by reference, but force a data type match. This means that if you have a REFERENCE TO INT you cannot pass a WORD or a BYTE or anything but an INT.  You can only set the reference - you cannot perform pointer math or shift memory locations.  This makes REFERENCE TO a safer alternative to pointers for passing by reference - it either is valid or it is empty.  They can be used for VAR_INPUTs, VAR_OUTPUTs and VARs but not for VAR_IN_OUTs.  If you define a REFERENCE TO as a VAR_INPUT, do not change the value inside your POU - use a VAR_IN_OUT for that.A POINTER TO is a variable that stores a memory location - thus a pass by reference.  It is often a DWORD size (but is hardware dependent).  If you dereference the pointer, you see the data.  However, unlike REFERENCE TO, you can do pointer math and shift the memory location to look at a different spot in memory.  Additionally, you can dereference to a different data type.  If you do it wrong, you get wrong answers and if you write to wrong memory locations, you can cause your control to crash.  Many companies don’t allow using pointers for this reason and even the PLCopen programming standards say to not use them.  In the C# language you must add the keyword UNSAFE even if you want to use them.  They can be used for VAR_INPUTs, VAR_OUTPUTs, VARs and I believe VAR_IN_OUTs.All three have times when they perform the best over the other two, even though they are all a “by reference” variable pass.

_________________Scott CunninghamKEB America, Inc.www.kebblog.comwww.kebamerica.com

When I say language semantics I am referring to how statements are written, what the compiler allows, disallows, requires, etc .  A REFERENCE TO variable occupies the same amount of memory space as a POINTER TO variable and both contain the memory address of the variable to which they point or reference.   A VAR_IN_OUT parameter also contains a memory address which refers to another variable.

You are correct but they each have a different use and place, just like a INT, UINT and WORD occupy the same space and are both a number, but I wouldn't say this is just semantics... You can use a pointer for everything, if you choose.  In the original question, I felt it was important to explain why a soft motion function block uses VAR_IN_OUT for the axis data.

_________________Scott CunninghamKEB America, Inc.www.kebblog.comwww.kebamerica.com

I don't think we disagree (except possibly on my use of "semantics".    My point is that pointer by any other name is still a pointer.

