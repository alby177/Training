Hello Everyone.I have to implement one of recursive algorithms as one of optimization methods.Is there any way to implement recursion in CODESYS?I work in ST, but any language is fine.Best regardsSinuhe

Sinuhe wrote:Hello Everyone.I have to implement one of recursive algorithms as one of optimization methods.Is there any way to implement recursion in CODESYS?I work in ST, but any language is fine.Best regardsSinuheSeeviewtopic.php?p=18455#p18455

Be careful with recursion and machine controls.  The PLCopen programming guidelines state recursion should not be used in an application.  Iteration should be used instead.  See attached PNG of the pages.  Computer theory loves the "tidiness" of recursion, but it can be big trouble for hardware.  It's no big deal if your PC hangs an extra 10 or 20 ms because of some deep recursion (you may not even notice) - but for machine coordinated motion, this is a big no-no.Good luck!Attachment:plcopen_coding_guidelines_v10_recursion1.pngAttachment:plcopen_coding_guidelines_v10_recursion2.png

_________________Scott CunninghamKEB America, Inc.www.kebblog.comwww.kebamerica.com

scott_cunningham wrote:Be careful with recursion and machine controls.  The PLCopen programming guidelines state recursion should not be used in an application.  Iteration should be used instead.  See attached PNG of the pages.  Computer theory loves the "tidiness" of recursion, but it can be big trouble for hardware.  It's no big deal if your PC hangs an extra 10 or 20 ms because of some deep recursion (you may not even notice) - but for machine coordinated motion, this is a big no-no.Good luck!Attachment:plcopen_coding_guidelines_v10_recursion1.pngAttachment:plcopen_coding_guidelines_v10_recursion2.pngHi Scot.It is possible to know where to find this document?

Thanks for Your answers.Of course i know the danger of using recursion, but in first step I just want to check possibilities and the calculation if any will be made out of machine process. The next step would be change the recursion to iteration. Josep M. Rams, please tell me, where can I find more information about THIS^() directive? Best RegardsSinuhe

Hi."This" is simply the pointrer to the fb from which "this" is called ( like c++ or java...).But this^() executes the code wrote in the body of the function block.

You can find the programming guidelines at the PLCopen.org website:http://www.plcopen.org/pages/pc2_training/index.htm

_________________Scott CunninghamKEB America, Inc.www.kebblog.comwww.kebamerica.com

Thanks Scott.

HelloIn general i would also try to avoid recursion, even in non Machinecontrol environments. But there are several cases where its way better than "doing it with iterations".If you have do it for conceptional reasons, keep in mind that doing it with a "Function" will always copy all your variables on a call, on a function block it doesn't. Depending on what you want to achieve this is a not so obvious difference between Functions and Function Blocks.Function Block:https://help.codesys.com/webapp/cds-obj ... n=3.5.11.0"After execution the values of the output variables and the internal variables are retained until the next execution. This means that the function block does not necessarily supply the same output values with the same input variables when called repeatedly."Function:https://help.codesys.com/webapp/cds-obj ... n=3.5.11.0"Functions have no internal status information, which means that functions do not save the values of their variables until the next call. Calls of a function with the same input variable values always supply the same output value. Therefore, functions may not use global variables and addresses!"Keep also in mind that if you do it with methods, all the variables provided in the method siganture are copied to the stack. If you would pass large objects in functions method and you have deep callstacks because of the recursion, callstack size resp. memory "waste" could be worth looking at.

Hi.It s clear that a recursive code could cause stack troubles. But this kind of code could avoid the use of nested "fors".A recursive code could:Launch an stack exceptionLaunch an timeout exception.The exception stops the plc code and safety plc would have to go to safe state (if it is an ethercat slave f.ex)If we use "fors" (which normally runs over arrays) can cause the code is more complicated, dificult to read, and it is not dificult to make sintatic mistakes, and boundary problems on arrays. This errors can be more dangerous (if the array manages axes positions f ex.) than an exception, because the plc don t stops, has an error, and we don t know where.

Like everything else, recursion done incorrectly can lead to big problems.  However, the converse is also true.Use methods, don't pass whole data structures as parameters, pass index/ptr instead, don't pass unnecessary parameters, limit absolute and per scan depth and observe rules of re-entrancy.  Of course, the same advice applies to iteration methodology just as well.And of course there is always the possibility to create separate (lower priority) tasks for data intensive algorithms whose execution time exceeds process control scan time requirements.Several years ago I built a control system comprised of hierarchically linked objects.  Each object kept a directory of it's immediate children.  I implemented a very simple search-by-name method that took a path string as input and returned an object reference.  The method stripped out the first element of the path, if a child of that name was found in the local directory, then the remaining path was passed to the child object's find method.  The process would continue until the remaining path was empty or maxdepth was reached.

Not sure whether there are enough of right answers given to judge on the usage or avoidance of recursion in motion controlled systems. However, in order to answer myself a question on where VAR_INST variables are located I created a "5-line" recursive function. You'd find it here: https://forum-de.codesys.com/viewtopic.php?f=10&t=5514So in principle it is possible but I'd avoid it too if there's another way of doing the same. 

