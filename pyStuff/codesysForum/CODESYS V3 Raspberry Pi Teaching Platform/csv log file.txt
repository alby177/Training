Hello, I am trying to create a CSV log file. I have a string within my programme that contains a few variables, some sensor data and internal calculations.Here's my predicament, as the data in my string changes, I need to write the data every time FiWr becomes true. This is happening with the code below, however each time FiWr becomes true and writes the string to the CSV file it overwrites the existing data, so no matter how many times FiWr becomes true I only ever have one line in my CSV file. I would like to see a new line written to the CSV file each time FiWr becomes true. Code:STR1:= CONCAT(TEMPSTRINGCO, FACSTRINGCO);STR2:= CONCAT(COUNTSTRINGCO, '$R$N');FINSTR:= CONCAT(STR1, STR2);xFileStdInit:= RUN;IF NOT xFileStdInit THEN    filop(xExecute:=FALSE);    filcl(xExecute:=FALSE);    filwr(xExecute:=FALSE);    filrd(xExecute:=FALSE);    xFileStdInit:=TRUE;    uiFileStdState:=0;ELSE    CASE uiFileStdState OF        0:(* create a new file *)            filop.sFileName:=sFileName;            filop.eFileMode:=FILE.MODE.MRDWR;            filop.xExclusive:=TRUE;            filop( xExecute:=TRUE);            IF filop.xDone THEN                hFile:=filop.hFile;                uiFileStdState:=1;            END_IF            IF filop.xError THEN                (* error handling*)                ;            END_IF                 1:(* close file  - TestFile.txt *)            filcl.hFile:=hFile;            filcl( xExecute:=TRUE);            IF filcl.xDone THEN                uiFileStdState:=2;            END_IF            IF filcl.xError THEN                (* error handling*)                ;            END_IF        2:(* end of example *)            ;    END_CASEEND_IFIF NOT  FiWr THEN    filop(xExecute:=FALSE);    filcl(xExecute:=FALSE);    filwr(xExecute:=FALSE);    filrd(xExecute:=FALSE);   filgp(xExecute:=FALSE);   filsp(xExecute:=FALSE);   FiWr:= TRUE;    csvwrite:=0;ELSE    CASE csvwrite OF        0:(* create a new file *)            filop.sFileName:=sFileName;            filop.eFileMode:=FILE.MODE.MAPPD;            filop.xExclusive:=TRUE;            filop( xExecute:=TRUE);            IF filop.xDone THEN                hFile:=filop.hFile;               csvwrite:=1;            END_IF            IF filop.xError THEN                (* error handling*)                ;            END_IF                     1:(* get actual internal positon file pointer *)                 filgp.hFile:= hFile;               filgp (xExecute:=TRUE);                filgp.xBusy;             filgp.xError;                filgp.eError;                 IF filgp.xDone  THEN                 WritePoint:=filgp.udiPos;                 csvwrite:=2;            END_IF            IF filgp.xError THEN               (* error handling*);                END_IF                           2:(* set actual internal positon file pointer *)                 filsp.hFile:= hFile;             filsp (udiPos:=WritePoint);               filsp (xExecute:=TRUE);               filsp.xBusy;             filsp.xError;                filsp.eError;                                 IF filsp.xDone  THEN                 csvwrite:=3;            END_IF            IF filgp.xError THEN               (* error handling*);                END_IF        3:(* write text in the file *)            filwr.hFile:=hFile;            filwr.pBuffer:=ADR(FINSTR);            szFileSize1:=SIZEOF(FINSTR);            filwr.szSize:=szFileSize1;            filwr.udiTimeOut:=100000;    (* 100ms Timeout *)            filwr( xExecute:=TRUE);            IF filwr.xDone THEN                csvwrite:=4;            END_IF            IF filwr.xError THEN                (* error handling*)                ;            END_IF        4:(* close file  - TestFile.txt *)            filcl.hFile:=hFile;            filcl( xExecute:=TRUE);            IF filcl.xDone THEN                csvwrite:=5;            END_IF            IF filcl.xError THEN                (* error handling*)                ;            END_IF        5:(* end of example *)            ;    END_CASEEND_IF

Hi Primative Source,I have used the following code in a function block,Put these variables in you variable editor:Code://This Function block requires SysFile = SysFile, 3.5.6.0 in the Library ManagerFUNCTION_BLOCK TEXT_TO_FILEVAR_INPUT   xFilePath: STRING;   xText_Write: STRING(2000);   xAppend_OverWrite: BOOL;   xAppend_Pos: UDINT;   xWrite: BOOL;   xRead: BOOL;   xLine_No_To_Read: UDINT;   END_VARVAR_OUTPUT   xText_Read: STRING(2000);   xDone: BOOL;END_VARVAR   // Write Variables   xWrite_Trig: R_TRIG;   xStart_Write: BOOL;   xNew_Line: STRING(2000);   // Read Variables   xRead_Trig: R_TRIG;   xStart_Read: BOOL;   xLine_Read: UDINT;      hFile           : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;   udiBytesRead    : UDINT;   udiBytesCopied   : UDINT;   udiWrite      : UDINT;   udiFileSize     : UDINT;   udiPos         : UDINT;//(* Error Codes *)   udiPosError          : RTS_IEC_RESULT;   udiCopyError      : RTS_IEC_RESULT;   udiDeleteError1      : RTS_IEC_RESULT;   udiDeleteError2      : RTS_IEC_RESULT;   udiWriteError1      : RTS_IEC_RESULT;   udiWriteError2      : RTS_IEC_RESULT;   udiWriteError3      : RTS_IEC_RESULT;   udiOpenError1      : RTS_IEC_RESULT;   udiOpenError2      : RTS_IEC_RESULT;   udiOpenError3      : RTS_IEC_RESULT;   udiOpenError4      : RTS_IEC_RESULT;   udiReadError1   : RTS_IEC_RESULT;   udiReadError2   : RTS_IEC_RESULT;   udiReadError3   : RTS_IEC_RESULT;   udiCloseError1   : RTS_IEC_RESULT;   udiCloseError2   : RTS_IEC_RESULT;   udiCloseError3   : RTS_IEC_RESULT;   udiCloseError4   : RTS_IEC_RESULT;   udiSizeError : RTS_IEC_RESULT;   udiDirDeleteError: UDINT;    udiCreateError: UDINT;END_VARThen paste this code into the editor.Code:xWrite_Trig();//xWrite_Trig.PT:= T#500MS;xWrite_Trig.CLK:= xWrite;xStart_Write:= xWrite_Trig.Q;xRead_Trig();//xRead_Trig.PT:= T#500MS;xRead_Trig.CLK:= xRead;xStart_Read:= xRead_Trig.Q;IF xStart_Write THEN   xDone:= FALSE;   IF xAppend_OverWrite THEN    hFile:= SysFileOpen(szFile:= xFilePath, am:= ACCESS_MODE.AM_APPEND, pResult:= ADR(udiOpenError1));   END_IF   IF xAppend_OverWrite = FALSE THEN      hFile:= SysFileOpen(szFile:= xFilePath, am:= ACCESS_MODE.AM_WRITE_PLUS, pResult:= ADR(udiOpenError1));   END_IF   udiPosError:= SysFileGetPos(hFile:= hFile, pulPos:= ADR(udiPos));   IF hFile <> RTS_INVALID_HANDLE THEN      xNew_Line:= concat('$n', xText_Write);      IF udiPos = 16#0 THEN         udiWrite:= SysFileWrite(hFile:= hFile, pbyBuffer:= ADR(xText_Write), ulSize:= INT_TO_UDINT(LEN(xText_Write)), pResult:= ADR(udiWriteError1));      ELSE         udiWrite:= SysFileWrite(hFile:= hFile, pbyBuffer:= ADR(xNew_Line), ulSize:= INT_TO_UDINT(LEN(xNew_Line)), pResult:= ADR(udiWriteError1));      END_IF      udiCloseError1:= SysFileClose(hFile:= hFile);   END_IF   xDone:= TRUE;END_IFIF xStart_Read THEN   xDone:= FALSE;   hFile:= SysFileOpen(szFile:= xFilePath, am:= ACCESS_MODE.AM_READ, pResult:= ADR(udiOpenError1));   IF hFile <> RTS_INVALID_HANDLE THEN      udiBytesRead := SysFileRead(hFile:= hFile, pbyBuffer:= ADR(xText_Read), ulSize:=SIZEOF(xText_Read), pResult:=ADR(udiReadError1));      xText_Read[udiBytesRead]:= 0;   END_IF   //xDone:= TRUE;   END_IFBe sure that you feed the TEXT_TO_FILE function block with a line that is already in a csv format for example,variable1,variable2,variable3,variable4You will see in the code that there is a xNew_Line variable that has the '$n' token to add the new line.Hope this helps, Best RegardsJohan

Hi johan76swart, hi Primitive Source,I've seen many similar examples of code like yours. For me, I want to have a program which can write and read a csv file in a certain directory. The problem is, that I couldn't figure out until now, where the file is saved/ or if I gave a certain file path, it wouldn't appear... It would mean a great deal to me, if you could enlighten me a bit!Kind regards,SpeedyG

